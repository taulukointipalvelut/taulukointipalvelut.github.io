<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>DocStrap Source: core.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	<link type="text/css" rel="stylesheet" href="styles/site.paper.css">

</head>

<body>

<div class="navbar navbar-default navbar-fixed-top navbar-inverse">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href="index.html">DocStrap</a>
		<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
        </button>
	</div>
	<div class="navbar-collapse collapse" id="topNavigation">
		<ul class="nav navbar-nav">
			
			<li class="dropdown">
				<a href="namespaces.list.html" class="dropdown-toggle" data-toggle="dropdown">Namespaces<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="Tournament.adjudicators.html">Tournament.adjudicators</a></li><li><a href="Tournament.adjudicators.results.html">Tournament.adjudicators.results</a></li><li><a href="Tournament.allocations.html">Tournament.allocations</a></li><li><a href="Tournament.debaters.html">Tournament.debaters</a></li><li><a href="Tournament.debaters.results.html">Tournament.debaters.results</a></li><li><a href="Tournament.institutions.html">Tournament.institutions</a></li><li><a href="Tournament.rounds.html">Tournament.rounds</a></li><li><a href="Tournament.teams.html">Tournament.teams</a></li><li><a href="Tournament.teams.debaters.html">Tournament.teams.debaters</a></li><li><a href="Tournament.teams.results.html">Tournament.teams.results</a></li><li><a href="Tournament.venues.html">Tournament.venues</a></li><li><a href="tournaments.html">tournaments</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="Tournament.html">Tournament</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="global.html" class="dropdown-toggle" data-toggle="dropdown">Global<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="global.html">Global</a></li>
				</ul>
			</li>
			
		</ul>
        
            <div class="col-sm-3 col-md-3">
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search" name="q" id="search-input">
                        <div class="input-group-btn">
                            <button class="btn btn-default" id="search-submit"><i class="glyphicon glyphicon-search"></i></button>
                        </div>
                    </div>
                </form>
            </div>
        
	</div>

</div>
</div>


<div class="container" id="toc-content">
<div class="row">

	
	<div class="col-md-12">
	
		<div id="main">
			

		<h1 class="page-title">Source: core.js</h1>
    
<section>
    <article>
        <pre
            class="sunlight-highlight-javascript linenums">"use strict";
/**
 * @module core
 * @author taulukointipalvelut@gmail.com (nswa17)
 * @file Interfaces for UTab core. Github Page is [here]{@link https://github.com/taulukointipalvelut/utab-core}.
 * @version 1.1
 * @example
 * var core = require('./core.js')
 *
 * core.tournaments.read().then(console.log)
 * var t1 = new core.Tournament({id: 1, name: "t1"})
 */

let op = require('./src/operations.js')
let controllers = require('./src/controllers.js')
let _ = require('underscore/underscore.js')

/**
 * Represents a pair/set of teams in a venue. A minimum unit to be an allocation.
 * @typedef Square
 * @property {Number} id id of the Square
 * @property {Number[]} teams teams in the Square
 * @property {Number[]} chairs chairs in the Square
 * @property {Number[]} remaining_adjudicators adjudicators(panels) in the Square
 * @property {Number[]} remaining_adjudicators2 adjudicators(trainees) in the Square
 * @property {String[]} warnings warnings
 * @property {Number} venue
 */

 /**
  * Represents a team.
  * @typedef Team
  * @property {Number} id id of the Team
  * @property {String} name name of the Team
  * @property {Boolean} available available
  * @property {String} url url of the Team
  */

  /**
   * Represents an adjudicator.
   * @typedef Adjudicator
   * @property {Number} id id of the Adjudicator
   * @property {Number} preev pre evaluation(judge test) of the Adjudicator
   * @property {String} name name of the Adjudicator
   * @property {Boolean} available available
   * @property {String} url url of the Adjudicator
   */

/**
 * Represents a venue.
 * @typedef Venue
 * @property {Number} id id of the Venue
 * @property {Number} priority priority of the Venue
 * @property {String} name name of the Venue
 * @property {Boolean} available available
 * @property {String} url url of the Venue
 */

/**
 * Represents an institution.
 * @typedef Institution
 * @property {Number} id id of the Institution
 * @property {String} name name of the Institution
 * @property {Boolean} available available
 * @property {String} url url of the Institution
 */

 /**
  * Represents raw team result.
  * @typedef RawTeamResult
  * @property {Number} id id of the team to evaluate
  * @property {Number} from_id id of the sender
  * @property {Number} r round number at which the result is sent
  * @property {Number} win in NA it's either 1(win) or 0(lose), in BP it's the win-points
  * @property {Number[]} opponents opponents of the team
  * @property {String} side side of the team
  * @example
  * {
  *   id: 1,
  *   from_id: 2,
  *   r: 1,
  *   win: 1,
  *   opponents: [2],
  *   side: "gov"
  * }
  */

/**
* Represents raw debater result.
* @typedef RawDebaterResult
* @property {Number} id id of the debater to evaluate
* @property {Number} from_id id of the sender
* @property {Number} r round number at which the result is sent
* @property {Number[]} scores scores the sender writes
* @example
* {
*   id: 1,
*   from_id: 2,
*   r: 1,
*   scores: [75, 0, 36.5]
* }
*/

/**
 * Represents raw adjudicator result.
 * @typedef RawAdjudicatorResult
 * @property {Number} id id of the adjudicator to evaluate
 * @property {Number} from_id id of the sender
 * @property {Number} r round number at which the result is sent
 * @property {Number} score the score of the adjudicator the sender writes
 * @property {Number[]} watched_teams teams the adjudicator watched
 * @property {String} [comment] the comment for the adjudicator from the sender
 */

/**
 * Represents debate style.
 * @typedef Style
 * @property {String} name style name
 * @property {Number} debater_num_per_team number of debaters per team
 * @property {Number} team_num number of team in a [Square]{@link Square}
 * @property {Number[]} score_weights weights of the scores
 * @property {Number} replies candidates of replies (Necessary only for testing)
 * @property {Number} reply_num number of replies in a [Square]{@link Square} (Necessary only for testing)
 * @example
 * {
 * name: "ASIAN",
 *  debater_num_per_team: 3,
 *  team_num: 2,
 *  score_weights: [1, 1, 1, 0.5],
 *  replies: [0, 1],
 *  reply_num: 1
 * }
 */

/**
 * Represents a tournament.
 * @typedef TournamentInformation
 * @property {Number} id id of the tournament
 * @property {String} name name of the tournament
 * @property {String} url url of the tournament
 * @property {Number} current_round_num current round
 * @property {Number} total_round_num total round
 * @property {Style} style style of the tournament
 */

 /**
  * Provides Interfaces related to tournaments
  * @namespace tournaments
  */
  var tournaments = controllers.tournaments
 /**
  * reads all tournaments.//1.1TESTED//
  * @name tournaments.read
  * @memberof! tournaments
  * @function tournaments.read
  * @return {Promise.&lt;Tournament[]>}
  */
  /**
   * create a tournament. //1.1TESTED//
   * @name tournaments.create
   * @memberof! tournaments
   * @function tournaments.create
   * @param tournament
   * @param {Number} tournament.id tournament id
   * @param {String} [tournament.tournament.name] tournament name
   * @param {String} [tournament.url] tournament url
   * @param {Style} [tournament.style] debating style
   * @param {Number} [tournament.total_round_num] total round
   * @param {Number} [tournament.current_round_num] current round(default 1)
   */
 /**
  * @name tournaments.update
  * @memberof! tournaments
  * @function tournaments.update
  */
  /**
   * @name tournaments.delete
   * @memberof! tournaments
   * @function tournaments.delete
   */


/**
 * A class to operate a tournament.
 */
class Tournament {
    /**
     * @param {Number} id - Unique ID of the tournament
     */
    constructor (dict) {
        var con = new controllers.CON(dict)
        /**
         * Provides Interfaces related to teams
         * @memberof Tournament
         * @namespace Tournament.teams
         */
        this.teams = con.teams
        /**
         * returns all teams(No side effect)
         * @name Tournament.teams.read
         * @memberof! Tournament.teams
         * @function Tournament.teams.read
         * @return {Promise.&lt;Team[]>} Teams
         */

        /**
         * creates team.//TESTED//
         * Attention: It throws an error if the specified team already exists.
         * @name Tournament.teams.create
         * @memberof! Tournament.teams
         * @function Tournament.teams.create
         * @param team
         * @param {Number} team.id id of the team to create
         * @param {Number} [team.name=""] name of the team to create
         * @param {Number} [team.available=true] id of the team to create
         * @param {Number} [team.url=""] id of the team to create
         * @return {Promise.&lt;Team>} Created team
         * @throws {Promise} AlreadyExists
         */
        /**
         * deletes specified team.//TESTED//
         * Attention: It throws an error if the specified team does not exist.
         * @name Tournament.teams.delete
         * @memberof! Tournament.teams
         * @function Tournament.teams.delete
         * @param team
         * @param {Number} team.id id of the team to delete
         * @return {Promise.&lt;Team>} Deleted team
         * @throws {Promise} DoesNotExist
         */
        /**
         * finds on specified condition(No side effect)//TESTED//
         * @name Tournament.teams.find
         * @memberof! Tournament.teams
         * @function Tournament.teams.find
         * @param team
         * @param {Number} [team.id] id of the team to find
         * @param {Number} [team.name] name of the team to find
         * @param {Number} [team.available] id of the team to find
         * @param {Number} [team.url] id of the team to find
         * @return {Promise.&lt;Team[]>} Teams
         */
        /**
         * updates specified team//TESTED//
         * Attention: It throws an error if the specified team does not exist.
         * @name Tournament.teams.update
         * @memberof! Tournament.teams
         * @function Tournament.teams.update
         * @param team
         * @param {Number} team.id id of the team to update
         * @param {Number} [team.name=""] name of the team to update
         * @param {Number} [team.available=true] id of the team to update
         * @param {Number} [team.url=""] id of the team to update
         * @return {Promise.&lt;Team>} Updated team
         * @throws DoesNotExist
         */
        /**
         * @namespace Tournament.teams.results
         * @memberof Tournament.teams
         */
        /**
         * reads all raw team results(No side effect)
         * @name Tournament.teams.results.read
         * @memberof! Tournament.teams.results
         * @function Tournament.teams.results.read
         * @returns {Promise.&lt;RawTeamResult[]>}
         */
        /**
         * Summarizes team results(No side effect)
         * @alias Tournament.teams.results.organize
         * @memberof! Tournament.teams.results
         * @param  {(Number | Number[])} r_or_rs round number(s) used to summarize results
         * @param options options for summarization
         * @param {Boolean} options.simple only use team results. No debater results is considered thus unable to output team points
         * @param {Boolean} options.force if true, it does not check raw results(not recommended)
         * @return {Promise} summarized team results
         */
        this.teams.results.organize = function(r_or_rs, {simple: simple=false, force: force=false}) {
            if (simple) {
                return Promise.all([con.teams.read(), con.teams.results.read()]).then(function (vs) {
                    var [teams, raw_team_results] = vs
                    if (!force) {
                        Array.isArray(r_or_rs) ? r_or_rs.map(r => op.teams.results.check(raw_team_results, teams, r)) : op.teams.results.check(raw_team_results, teams, r_or_rs)
                    }
                    return Array.isArray(r_or_rs) ? op.results.teams.simplified_compile(teams, raw_team_results, r_or_rs) : op.results.teams.simplified_summarize(teams, raw_team_results, r_or_rs)
                })
            } else {
                return Promise.all([con.teams.read(), con.teams.debaters.read(), con.teams.debaters.read(), con.teams.results.read(), con.debaters.results.read(), con.teams.debaters.read(), con.rounds.read()]).then(function (vs) {
                    var [teams, debaters, raw_teams_to_debaters, raw_team_results, raw_debater_results, raw_teams_to_debaters, round_info] = vs
                    if (!force) {
                        op.results.precheck(teams, raw_teams_to_debaters, debaters)
                        if (Array.isArray(r_or_rs)) {
                            r_or_rs.map(r => op.teams.results.check(raw_team_results, teams, r))
                            r_or_rs.map(r => op.debaters.results.check(raw_debater_results, debaters, r))
                        } else {
                            op.teams.results.check(raw_team_results, teams, r_or_rs)
                            op.debaters.results.check(raw_debater_results, debaters, r_or_rs)
                        }
                    }
                    return Array.isArray(r_or_rs) ? op.results.teams.compile(teams, debaters, raw_teams_to_debaters, raw_team_results, raw_debater_results, round_info.style, r_or_rs) : op.results.teams.summarize(teams, debaters, raw_teams_to_debaters, raw_team_results, raw_debater_results, round_info.style, r_or_rs)
                })
            }
        }

        /**
         * Interfaces related to teams to debaters
         * @namespace Tournament.teams.debaters
         * @memberof Tournament.teams
         */
        /**
         * returns teams to debaters(No side effect)
         * @name Tournament.teams.debaters.read
         * @memberof! Tournament.teams.debaters
         * @function Tournament.teams.debaters.read
         * @return {Promise} Teams to debaters
         */
        /**
         * sets debaters to a team.
         * Attention: It throws an error if the specified team has debaters.
         * @name Tournament.teams.debaters.create
         * @memberof! Tournament.teams.debaters
         * @function Tournament.teams.debaters.create
         * @param dict
         * @param {Number} dict.id id of the team to set debaters
         * @param {Number[]} dict.debaters debaters to set
         * @param {Number} dict.r round where the team has the debaters
         * @return {Promise} Created team
         * @throws {Promise} AlreadyExists
         */
        /**
         * deletes debaters from specified team.
         * Attention: It throws an error if the specified team does not exist.
         * @deprecated
         * @name Tournament.teams.debaters.delete
         * @memberof! Tournament.teams.debaters
         * @function Tournament.teams.debaters.delete
         * @param options
         * @param {Number} options.id id of the team to delete
         * @param {Number} options.r round where the team has the debaters
         * @return {Promise} Team
         * @throws {Promise} DoesNotExist
         */
         /**
          * finds on specified condition(No side effect)
          * @name Tournament.teams.debaters.find
          * @memberof! Tournament.teams.debaters
          * @function Tournament.teams.debaters.find
          * @param options
          * @param {Number} [options.id] id of the team to delete
          * @param {Number} [options.r] round where the team has the debaters
          * @param {Number[]} [options.debaters] debaters
          * @return {Promise} Teams
          */
        /**
         * updates debaters of specified team
         * Attention: It throws an error if the specified team does not exist.
         * @name Tournament.teams.debaters.update
         * @memberof! Tournament.teams.debaters
         * @function Tournament.teams.debaters.update
         * @param options
         * @param {Number} options.id id of the team
         * @param {Number} options.r round where the team has the debaters
         * @param {Number[]} options.debaters debaters of the team
         * @return {Promi} Team
         * @throws DoesNotExist
         */

        /**
         * Provides interefaces related to teams to institutions
         */

        /**
         * Provides interfaces related to adjudicators
         * @namespace Tournament.adjudicators
         * @memberof Tournament
         */
        this.adjudicators = con.adjudicators
        /**
         * @namespace Tournament.adjudicators.results
         * @memberof Tournament.adjudicators
         */
        /**
         * Summarizes adjudicator results(No side effect)
         * @alias Tournament.adjudicators.results.organize
         * @memberof! Tournament.adjudicators.results
         * @param  {(Number | Number[])} r_or_rs round number(s) used to summarize results
         * @param options
         * @param {Boolean} options.force if true, it does not check raw results(not recommended)
         * @return {Promise} summarized adjudicator results
         */
        this.adjudicators.results.organize = function(r_or_rs, {force: force=false}) {
            return Promise.all([con.adjudicators.read(), con.adjudicators.results.read()]).then(function(vs) {
                var [adjudicators, raw_adjudicator_results] = vs
                if (!force) {
                    Array.isArray(r_or_rs) ? r_or_rs.map(r => op.adjudicators.results.check(raw_adjudicator_results, r)) : op.adjudicators.results.check(raw_adjudicator_results, r_or_rs)
                }
                return Array.isArray(r_or_rs) ? op.results.adjudicators.compile(adjudicators, raw_adjudicator_results, r_or_rs) : op.results.adjudicators.summarize(adjudicators, raw_adjudicator_results, r_or_rs)
            })
        }
        /**
         * Interfaces related to tournament operation
         * @namespace Tournament.rounds
         * @memberof Tournament
         */
        this.rounds = con.rounds
        /**
         * Interfaces related to venues
         * @namespace Tournament.venues
         * @memberof Tournament
         */
        this.venues = con.venues
        /**
         * Interfaces related to debaters
         * @namespace Tournament.debaters
         * @memberof Tournament
         */
        this.debaters = con.debaters
        /**
         * Interfaces related to debater results
         * @namespace Tournament.debaters.results
         * @memberof Tournament.debaters
         */
        /**
         * Summarizes debater results(No side effect)
         * @alias Tournament.debaters.results.organize
         * @memberof! Tournament.debaters.results
         * @param  {(Number | Number[])} r_or_rs round number(s) used to summarize results
         * @param options
         * @param {Boolean} options.force if true, it does not check raw results(not recommended)
         * @return {Promise} summarized debater results
         */
        this.debaters.results.organize = function(r_or_rs) {
            return Promise.all([con.debaters.read(), con.debaters.results.read()]).then(function(vs) {
                var [debaters, raw_debater_results] = vs
                Array.isArray(r_or_rs) ? r_or_rs.map(r => op.debaters.results.check(raw_debater_results, debaters, r)) : op.debaters.results.check(raw_debater_results, debaters, r_or_rs)
                return Array.isArray(r_or_rs) ? op.results.debaters.compile(debaters, raw_debater_results, r_or_rs) : op.results.debaters.summarize(debaters, raw_debater_results, r_or_rs)
            })
        }
        this.debaters.results.check = undefined
        /**
         * Interfaces related to institutions
         * @namespace Tournament.institutions
         * @memberof Tournament
         */
        this.institutions = con.institutions

        /**
         * Provides interfaces related to allocations
         * @namespace Tournament.allocations
         * @memberof Tournament
         */
        this.allocations = {
            /**
             * get allocation(No side effect)
             * @alias Tournament.allocations.get
             * @memberof! Tournament.allocations
             * @param options
             * @param  {Boolean} [options.simple=false] Does not use debater results
             * @param  {Boolean} [options.with_venues=false] Allocate venues
             * @param  {Boolean} [options.with_adjudicators=false] Allocate adjudicators
             * @param  {String[]} [options.filters=['by_strength', 'by_side', 'by_past_opponent', 'by_institution']] filters to use on computing team allocation
             * @param  {String[]} [options.adjudicator_filters=['by_bubble', 'by_strength', 'by_attendance', 'by_conflict', 'by_institution', 'by_past']] filters on computing adjudicator allocation
             * @param  {Square[]} [options.allocation] if specified, adjudicator/venue allocation will be created based on the allocation
             * @param {Boolean} [options.force] if true, it does not check the database before creating matchups. (false recommended)
             * @return {Promise.&lt;Square[]>} allocation
             */
            get: function({
                    simple: simple = false,
                    with_venues: with_venues = true,
                    with_adjudicators: with_adjudicators = true,
                    filters: filter_functions_strs=['by_strength', 'by_side', 'by_past_opponent', 'by_institution'],
                    adjudicator_filters: filter_functions_adj_strs=['by_bubble', 'by_strength', 'by_attendance', 'by_conflict', 'by_institution', 'by_past'],
                    allocation: allocation,
                    force: force = false
                }) {
                try {
                    var all_filter_functions = op.allocations.teams.functions.read()
                    var [all_filter_functions_adj, all_filter_functions_adj2] = op.allocations.adjudicators.functions.read()
                    var filter_functions = filter_functions_strs.map(f_str => all_filter_functions[f_str])
                    var filter_functions_adj = filter_functions_adj_strs.filter(f_str => all_filter_functions_adj.hasOwnProperty(f_str)).map(f_str => all_filter_functions_adj[f_str])
                    var filter_functions_adj2 = filter_functions_adj_strs.filter(f_str => all_filter_functions_adj2.hasOwnProperty(f_str)).map(f_str => all_filter_functions_adj2[f_str])
                } catch(e) {
                    return Promise.reject(e)
                }

                return con.rounds.read().then(function (round_info) {
                    var current_round_num = round_info.current_round_num
                    var considering_rounds = _.range(1, current_round_num)
                    return Promise.all([con.teams.read(), con.adjudicators.read(), con.venues.read(), con.institutions.read(), teams.results.organize(considering_rounds), adjudicators.results.organize(considering_rounds), con.teams.institutions.read(), con.adjudicators.institutions.read(), con.adjudicators.conflicts.read()]).then(function (vs) {
                        var [teams, adjudicators, venues, institutions, compiled_team_results, compiled_adjudicator_results, raw_teams_to_institutions, raw_adjudicators_to_institutions, raw_adjudicators_to_conflicts] = vs
                        if (!force) {
                            op.allocations.precheck(teams, adjudicators, venues, institutions, raw_teams_to_institutions, raw_adjudicators_to_institutions, raw_adjudicators_to_conflicts, round_info.style, current_round_num)
                        }
                        if (allocation) {
                            var new_allocation = op.allocations.deepcopy(allocation)
                        } else {
                            var new_allocation = op.allocations.teams.get(teams, compiled_team_results, raw_teams_to_institutions, filter_functions)
                        }

                        if (with_adjudicators) {
                            new_allocation = op.allocations.adjudicators.get(new_allocation, teams, adjudicators, compiled_team_results, compiled_adjudicator_results, raw_teams_to_institutions, raw_adjudicators_to_institutions, raw_adjudicators_to_conflicts, filter_functions_adj, filter_functions_adj2)
                        }
                        if (with_venues) {
                            new_allocation = op.allocations.venues.get(new_allocation, venues)
                        }
                        return new_allocation
                    })
                })
            },
            /**
             * checks allocation(No side effect)
             * @memberof! Tournament.allocations
             * @function Tournament.allocations.check
             * @param options
             * @param  {Boolean} [options.check_teams=true] check team allocation
             * @param  {Boolean} [options.check_adjudicators=true] check adjudicator allocation
             * @param  {Boolean} [options.check_venues=true] check venue allocation
             * @return {Promise.&lt;Square[]>}
             */
            check: function(allocation, {
                check_teams: check_teams = true,
                check_adjudicators: check_adjudicators = true,
                check_venues: check_venues = true
            }) {
                return Promise.all([con.teams.read(), con.adjudicators.read(), con.venues.read(), teams.results.organize(considering_rounds), adjudicators.results.organize(considering_rounds), con.teams.institutions.read(), con.adjudicators.institutions.read(), con.adjudicators.conflicts.read()]).then(function (vs) {
                    var [teams, adjudicators, venues, compiled_team_results, compiled_adjudicator_results, teams_to_institutions, adjudicators_to_institutions, adjudicators_to_conflicts] = vs

                    var new_allocation = op.allocations.deepcopy(allocation)
                    if (check_teams) {
                        new_allocation = op.allocations.teams.check(new_allocation, teams, compiled_team_results, teams_to_institutions)///////
                    }
                    if (check_adjudicators) {
                        new_allocation = op.allocations.adjudicators.check(new_allocation, new_allocation, teams, adjudicators, compiled_team_results, compiled_adjudicator_results, teams_to_institutions, adjudicators_to_institutions, adjudicators_to_conflicts, filter_functions_adj, filter_functions_adj2)
                    }
                    if (check_venues) {
                        new_allocation = op.allocations.venues.check(new_allocation, new_allocation, venues)
                    }
                    return new_allocation
                })
            }
        }
        /**
         * closes connection to the tournament database.
         * @memberof! Tournament
         * @function Tournament.close
         */
        this.close = con.close
    }
}

exports.tournaments = tournaments
exports.Tournament = Tournament
</pre>
    </article>
</section>





		</div>
	</div>

	<div class="clearfix"></div>

	

</div>
</div>


    <div class="modal fade" id="searchResults">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            <h4 class="modal-title">Search results</h4>
          </div>
          <div class="modal-body"></div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div>


<footer>


	<span class="copyright">
	DocStrap Copyright © 2012-2015 The contributors to the JSDoc3 and DocStrap projects.
	</span>

<span class="jsdoc-message">
	Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a>
	
		on Mon Nov 21st 2016
	
	using the <a href="https://github.com/docstrap/docstrap">DocStrap template</a>.
</span>
</footer>

<script src="scripts/docstrap.lib.js"></script>
<script src="scripts/toc.js"></script>

    <script type="text/javascript" src="scripts/fulltext-search-ui.js"></script>


<script>
$( function () {
	$( "[id*='$']" ).each( function () {
		var $this = $( this );

		$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
	} );

	$( ".tutorial-section pre, .readme-section pre, pre.prettyprint.source" ).each( function () {
		var $this = $( this );

		var example = $this.find( "code" );
		exampleText = example.html();
		var lang = /{@lang (.*?)}/.exec( exampleText );
		if ( lang && lang[1] ) {
			exampleText = exampleText.replace( lang[0], "" );
			example.html( exampleText );
			lang = lang[1];
		} else {
			var langClassMatch = example.parent()[0].className.match(/lang\-(\S+)/);
			lang = langClassMatch ? langClassMatch[1] : "javascript";
		}

		if ( lang ) {

			$this
			.addClass( "sunlight-highlight-" + lang )
			.addClass( "linenums" )
			.html( example.html() );

		}
	} );

	Sunlight.highlightAll( {
		lineNumbers : true,
		showMenu : true,
		enableDoclinks : true
	} );

	$.catchAnchorLinks( {
        navbarOffset: 10
	} );
	$( "#toc" ).toc( {
		anchorName  : function ( i, heading, prefix ) {
			return $( heading ).attr( "id" ) || ( prefix + i );
		},
		selectors   : "#toc-content h1,#toc-content h2,#toc-content h3,#toc-content h4",
		showAndHide : false,
		smoothScrolling: true
	} );

	$( "#main span[id^='toc']" ).addClass( "toc-shim" );
	$( '.dropdown-toggle' ).dropdown();

    $( "table" ).each( function () {
      var $this = $( this );
      $this.addClass('table');
    } );

} );
</script>



<!--Navigation and Symbol Display-->


<!--Google Analytics-->



    <script type="text/javascript">
        $(document).ready(function() {
            SearcherDisplay.init();
        });
    </script>


</body>
</html>
