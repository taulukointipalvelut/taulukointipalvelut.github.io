<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"utab.js.html":{"id":"utab.js.html","title":"Source: utab.js","body":" DocStrap Namespaces Tournament.adjudicatorsTournament.adjudicators.resultsTournament.allocationsTournament.allocations.adjudicatorsTournament.allocations.teamsTournament.allocations.venuesTournament.debatersTournament.debaters.resultsTournament.institutionsTournament.roundsTournament.teamsTournament.teams.debatersTournament.teams.resultsTournament.venues Classes Tournament Global Global Source: utab.js &quot;use strict&quot;; /** * @module utab * @author taulukointipalvelut@gmail.com (nswa17) * @file Interfaces for UTab core. Github Page is [here]{@link https://github.com/taulukointipalvelut/utab-core}. * @version 2.0 * @example * var utab = require('./utab.js') * * var t1 = new utab.Tournament({name: 't1', style: 'NA'})//create a tournament 't1' * t1.teams.read().then(console.log)//show all teams * * t1.close()//close connection to t1 database */ const loggers = require('./src/general/loggers.js')//Must be the first to require loggers.init() const alloc = require('./src/allocations.js') const res = require('./src/results.js') const checks = require('./src/checks.js') const controllers = require('./src/controllers.js') const _ = require('underscore/underscore.js') /** * Represents a pair/set of teams in a venue. A minimum unit to be an allocation. * @typedef Square * @property {Number} id id of the Square * @property {Number[]} teams teams in the Square * @property {Number[]} chairs chairs in the Square * @property {Number[]} panels adjudicators(panels) in the Square * @property {Number[]} trainees adjudicators(trainees) in the Square * @property {String[]} warnings warnings * @property {Number} venue */ /** * Represents a team. * @typedef Team * @property {Number} id id of the Team * @property {String} name name of the Team * @property {Boolean} available available * @property {Object} user_defined_data user defined data */ /** * Represents an adjudicator. * @typedef Adjudicator * @property {Number} id id of the Adjudicator * @property {Number} preev pre evaluation(judge test) of the Adjudicator * @property {String} name name of the Adjudicator * @property {Boolean} available available * @property {Object} user_defined_data user defined data */ /** * Represents a venue. * @typedef Venue * @property {Number} id id of the Venue * @property {Number} priority priority of the Venue * @property {String} name name of the Venue * @property {Boolean} available available * @property {Object} user_defined_data user defined data */ /** * Represents an institution. * @typedef Institution * @property {Number} id id of the Institution * @property {String} name name of the Institution * @property {Boolean} available available * @property {Object} user_defined_data user defined data */ /** * Represents raw team result. * @typedef RawTeamResult * @property {Number} id id of the team to evaluate * @property {Number} from_id id of the sender * @property {Number} r round number at which the result is sent * @property {Number} win in NA it's either 1(win) or 0(lose), in BP it's the win-points * @property {Number[]} opponents opponents of the team * @property {String} side side of the team * @property {Object} user_defined_data user defined data * @example * { * id: 1, * from_id: 2, * r: 1, * win: 1, * opponents: [2], * side: &quot;gov&quot; * } */ /** * Represents raw debater result. * @typedef RawDebaterResult * @property {Number} id id of the debater to evaluate * @property {Number} from_id id of the sender * @property {Number} r round number at which the result is sent * @property {Number[]} scores scores the sender writes * @property {Object} user_defined_data user defined data * @example * { * id: 1, * from_id: 2, * r: 1, * scores: [75, 0, 36.5] * } */ /** * Represents raw adjudicator result. * @typedef RawAdjudicatorResult * @property {Number} id id of the adjudicator to evaluate * @property {Number} from_id id of the sender * @property {Number} r round number at which the result is sent * @property {Number} score the score of the adjudicator the sender writes * @property {Number[]} watched_teams teams the adjudicator watched * @property {String} comment the comment for the adjudicator from the sender * @property {Object} user_defined_data user defined data */ /** * Represents debate style. * @typedef Style * @property {String} name style name * @property {Number} debater_num_per_team number of debaters per team * @property {Number} team_num number of team in a [Square]{@link Square} * @property {Number[]} score_weights weights of the scores * @property {Number} replies candidates of replies (Necessary only for testing) * @property {Number} reply_num number of replies in a [Square]{@link Square} (Necessary only for testing) * @example * { * name: &quot;ASIAN&quot;, * debater_num_per_team: 3, * team_num: 2, * score_weights: [1, 1, 1, 0.5], * replies: [0, 1], * reply_num: 1 * } */ /** * Represents a tournament. * @typedef TournamentInformation * @property {Number} id id of the tournament * @property {String} name name of the tournament * @property {Number} current_round_num current round * @property {Number} total_round_num total round * @property {Style} style style of the tournament * @property {Object} user_defined_data user defined data */ /** * A class to operate a tournament. */ class Tournament { /** * @param {Object} dict * @param {Number} dict.id tournament id * @param {String} [dict.name] tournament name * @param {Style} [dict.style] debate style */ constructor (dict) { var con = new controllers.CON(dict) var utab = this /** * Provides Interfaces related to teams * @memberof Tournament * @namespace Tournament.teams */ this.teams = con.teams /** * returns all teams(No side effect) * @name Tournament.teams.read * @memberof! Tournament.teams * @function Tournament.teams.read * @return {Promise.&lt;Team[]&gt;} Teams */ /** * creates team.//TESTED// * Attention: It throws an error if the specified team already exists. * @name Tournament.teams.create * @memberof! Tournament.teams * @function Tournament.teams.create * @param team * @param {Number} team.id id of the team to create * @param {Number} [team.name=&quot;&quot;] name of the team to create * @param {Number} [team.available=true] id of the team to create * @param {Boolean} [force=false] if true, it creates the specified team regardless of wheter the name specified already exists * @return {Promise.&lt;Team&gt;} Created team * @throws {Promise} AlreadyExists */ /** * deletes specified team.//TESTED// * Attention: It throws an error if the specified team does not exist. * @name Tournament.teams.delete * @memberof! Tournament.teams * @function Tournament.teams.delete * @param team * @param {Number} team.id id of the team to delete * @return {Promise.&lt;Team&gt;} Deleted team * @throws {Promise} DoesNotExist */ /** * finds on specified condition(No side effect)//TESTED// * @name Tournament.teams.find * @memberof! Tournament.teams * @function Tournament.teams.find * @param team * @param {Number} [team.id] id of the team to find * @param {Number} [team.name] name of the team to find * @param {Number} [team.available] id of the team to find * @return {Promise.&lt;Team[]&gt;} Teams */ /** * updates specified team//TESTED// * Attention: It throws an error if the specified team does not exist. * @name Tournament.teams.update * @memberof! Tournament.teams * @function Tournament.teams.update * @param team * @param {Number} team.id id of the team to update * @param {Number} [team.name=&quot;&quot;] name of the team to update * @param {Number} [team.available=true] id of the team to update * @return {Promise.&lt;Team&gt;} Updated team * @throws DoesNotExist */ /** * checks whether specified team exists * @name Tournament.teams.update * @memberof! Tournament.teams * @function Tournament.teams.update * @param team * @param {Number} [team.id] id of the team to update * @param {Number} [team.name] name of the team to update * @param {Number} [team.available] id of the team to update * @return {Promise.&lt;Boolean&gt;} * @throws DoesNotExist */ /** * @namespace Tournament.teams.results * @memberof Tournament.teams */ /** * reads all raw team results(No side effect) * @name Tournament.teams.results.read * @memberof! Tournament.teams.results * @function Tournament.teams.results.read * @returns {Promise.&lt;RawTeamResult[]&gt;} */ /** * Summarizes team results(No side effect) * @alias Tournament.teams.results.organize * @memberof! Tournament.teams.results * @param {(Number | Number[])} r_or_rs round number(s) used to summarize results * @param options [options] for summarization * @param {Boolean} [options.simple=false] only use team results. No debater results is considered thus unable to output team points * @param {Boolean} [options.force=false] if true, it does not check raw results(not recommended) * @return {Promise} summarized team results */ this.teams.results.organize = function(r_or_rs, {simple: simple=false, force: force=false}={}) { loggers.results('teams.results.organize is called') loggers.results('debug', 'arguments are: '+JSON.stringify(arguments)) if (simple) { return Promise.all([con.teams.read(), con.teams.results.read()]).then(function (vs) { var [teams, raw_team_results] = vs var team_num = round_info.style.team_num if (!force) { Array.isArray(r_or_rs) ? r_or_rs.map(r =&gt; checks.results.teams.check(raw_team_results, teams, r, team_num)) : checks.results.teams.check(raw_team_results, teams, r_or_rs, team_num) } return Array.isArray(r_or_rs) ? res.teams.simplified_compile(teams, raw_team_results, r_or_rs, round_info.style) : res.teams.simplified_summarize(teams, raw_team_results, r_or_rs, round_info.style) }) } else { return Promise.all([con.teams.read(), con.teams.debaters.read(), con.teams.debaters.read(), con.teams.results.read(), con.debaters.results.read(), con.teams.debaters.read(), con.rounds.read()]).then(function (vs) { var [teams, debaters, teams_to_debaters, raw_team_results, raw_debater_results, teams_to_debaters, round_info] = vs var team_num = round_info.style.team_num if (!force) { checks.results.check(teams, teams_to_debaters, debaters, team_num) if (Array.isArray(r_or_rs)) { r_or_rs.map(r =&gt; checks.results.teams.check(raw_team_results, teams, r, team_num)) r_or_rs.map(r =&gt; checks.results.debaters.check(raw_debater_results, debaters, r, team_num)) } else { checks.results.teams.check(raw_team_results, teams, r_or_rs, team_num) checks.results.debaters.check(raw_debater_results, debaters, r_or_rs, team_num) } } return Array.isArray(r_or_rs) ? res.teams.compile(teams, debaters, teams_to_debaters, raw_team_results, raw_debater_results, r_or_rs, round_info.style) : res.teams.summarize(teams, debaters, teams_to_debaters, raw_team_results, raw_debater_results, r_or_rs, round_info.style) }) } } /** * Interfaces related to teams to debaters * @namespace Tournament.teams.debaters * @memberof Tournament.teams */ /** * returns teams to debaters(No side effect) * @name Tournament.teams.debaters.read * @memberof! Tournament.teams.debaters * @function Tournament.teams.debaters.read * @return {Promise} Teams to debaters */ /** * sets debaters to a team. * Attention: It throws an error if the specified team has debaters. * @name Tournament.teams.debaters.create * @memberof! Tournament.teams.debaters * @function Tournament.teams.debaters.create * @param dict * @param {Number} dict.id id of the team to set debaters * @param {Number[]} dict.debaters debaters to set * @param {Number} dict.r round where the team has the debaters * @return {Promise} Created team * @throws {Promise} AlreadyExists */ /** * deletes debaters from specified team. * Attention: It throws an error if the specified team does not exist. * @deprecated * @name Tournament.teams.debaters.delete * @memberof! Tournament.teams.debaters * @function Tournament.teams.debaters.delete * @param options * @param {Number} options.id id of the team to delete * @param {Number} options.r round where the team has the debaters * @return {Promise} Team * @throws {Promise} DoesNotExist */ /** * finds on specified condition(No side effect) * @name Tournament.teams.debaters.find * @memberof! Tournament.teams.debaters * @function Tournament.teams.debaters.find * @param options * @param {Number} [options.id] id of the team to delete * @param {Number} [options.r] round where the team has the debaters * @param {Number[]} [options.debaters] debaters * @return {Promise} Teams */ /** * updates debaters of specified team * Attention: It throws an error if the specified team does not exist. * @name Tournament.teams.debaters.update * @memberof! Tournament.teams.debaters * @function Tournament.teams.debaters.update * @param options * @param {Number} options.id id of the team * @param {Number} options.r round where the team has the debaters * @param {Number[]} options.debaters debaters of the team * @return {Promi} Team * @throws DoesNotExist */ /** * Provides interefaces related to teams to institutions */ /** * Provides interfaces related to adjudicators * @namespace Tournament.adjudicators * @memberof Tournament */ this.adjudicators = con.adjudicators /** * @namespace Tournament.adjudicators.results * @memberof Tournament.adjudicators */ /** * Summarizes adjudicator results(No side effect) * @alias Tournament.adjudicators.results.organize * @memberof! Tournament.adjudicators.results * @param {(Number | Number[])} r_or_rs round number(s) used to summarize results * @param [options] * @param {Boolean} [options.force=false] if true, it does not check raw results(not recommended) * @return {Promise} summarized adjudicator results */ this.adjudicators.results.organize = function(r_or_rs, {force: force=false}={}) { loggers.results('adjudicators.results.organize is called') loggers.results('debug', 'arguments are: '+JSON.stringify(arguments)) return Promise.all([con.adjudicators.read(), con.adjudicators.results.read(), con.rounds.get()]).then(function(vs) { var [adjudicators, raw_adjudicator_results, round_info] = vs var team_num = round_info.style.team_num if (!force) { Array.isArray(r_or_rs) ? r_or_rs.map(r =&gt; checks.results.adjudicators.check(raw_adjudicator_results, adjudicators, r, team_num)) : checks.results.adjudicators.check(raw_adjudicator_results, adjudicators, r_or_rs, team_num) } return Array.isArray(r_or_rs) ? res.adjudicators.compile(adjudicators, raw_adjudicator_results, r_or_rs) : res.adjudicators.summarize(adjudicators, raw_adjudicator_results, r_or_rs) }) } /** * Interfaces related to tournament operation * @namespace Tournament.rounds * @memberof Tournament */ this.rounds = con.rounds /** * Interfaces related to venues * @namespace Tournament.venues * @memberof Tournament */ this.venues = con.venues /** * Interfaces related to debaters * @namespace Tournament.debaters * @memberof Tournament */ this.debaters = con.debaters /** * Interfaces related to debater results * @namespace Tournament.debaters.results * @memberof Tournament.debaters */ /** * Summarizes debater results(No side effect) * @alias Tournament.debaters.results.organize * @memberof! Tournament.debaters.results * @param {(Number | Number[])} r_or_rs round number(s) used to summarize results * @param [options] * @param {Boolean} [options.force=false] if true, it does not check raw results(not recommended) * @return {Promise} summarized debater results */ this.debaters.results.organize = function(r_or_rs, {force: force=false}={}) { loggers.results('debaters.results.organize is called') loggers.results('debug', 'arguments are: '+JSON.stringify(arguments)) return Promise.all([con.debaters.read(), con.debaters.results.read(), con.rounds.read()]).then(function(vs) { var [debaters, raw_debater_results, round_info] = vs var team_num = round_info.style.team_num if (!force) { Array.isArray(r_or_rs) ? r_or_rs.map(r =&gt; checks.results.debaters.check(raw_debater_results, debaters, r, team_num)) : checks.results.debaters.check(raw_debater_results, debaters, r_or_rs, team_num) } return Array.isArray(r_or_rs) ? res.debaters.compile(debaters, raw_debater_results, round_info.style, r_or_rs) : res.debaters.summarize(debaters, raw_debater_results, round_info.style, r_or_rs) }) } /*/** * checks debater results are all gathered * @alias Tournament.debaters.results.check * @memberof! Tournament.debaters.results * @throws error */ //this.debaters.results.check = checks.debaters.check /** * Interfaces related to institutions * @namespace Tournament.institutions * @memberof Tournament */ this.institutions = con.institutions /** * Provides interfaces related to allocations * @namespace Tournament.allocations * @memberof Tournament */ this.allocations = con.allocations this.allocations.check = function() { loggers.allocations('allocations.check is called') loggers.allocations('debug', 'arguments are: '+JSON.stringify(arguments)) return con.rounds.read().then(function (round_info) { var current_round_num = round_info.current_round_num var considering_rounds = _.range(1, current_round_num) return Promise.all([con.teams.read(), con.adjudicators.read(), con.venues.read(), con.institutions.read(), utab.teams.results.organize(considering_rounds), utab.adjudicators.results.organize(considering_rounds), con.teams.institutions.read(), con.adjudicators.institutions.read(), con.adjudicators.conflicts.read()]).then(function (vs) { var [teams, adjudicators, venues, institutions, compiled_team_results, compiled_adjudicator_results, teams_to_institutions, adjudicators_to_institutions, adjudicators_to_conflicts] = vs checks.allocations.check(teams, adjudicators, venues, institutions, teams_to_institutions, adjudicators_to_institutions, adjudicators_to_conflicts, round_info.style, current_round_num) }) }) } /** * Provides interfaces related to team allocation * @namespace Tournament.allocations.teams * @memberof Tournament.allocations */ this.allocations.teams = { //@param {String[]} [options.adjudicator_filters=['by_bubble', 'by_strength', 'by_attendance', 'by_conflict', 'by_institution', 'by_past']] filters on computing adjudicator allocation //@param {Square[]} [options.allocation] if specified, adjudicator/venue allocation will be created based on the allocation /** * get allocation(No side effect) * @alias Tournament.allocations.teams.get * @memberof! Tournament.allocations.teams * @param {Object} [options] * @param {Boolean} [options.simple=false] if true, it does not use debater results * @param {String[]} [options.filters=['by_strength', 'by_side', 'by_past_opponent', 'by_institution']] filters to compute team allocation in `standard` algorithm * @param {Boolean} [options.force=false] if true, it does not check the database before creating matchups. (false recommended) * @param {String} [options.algorithm='standard'] it computes the allocation using specified algorithm * @return {Promise.&lt;Square[]&gt;} allocation */ get: function({ simple: simple = false, filters: filters=['by_strength', 'by_side', 'by_past_opponent', 'by_institution'], force: force=false, // ignores warnings from processing results algorithm: algorithm = 'standard' }={}) { loggers.allocations('allocations.teams.get is called') loggers.allocations('debug', 'arguments are: '+JSON.stringify(arguments)) return con.rounds.read().then(function (round_info) { var current_round_num = round_info.current_round_num var considering_rounds = _.range(1, current_round_num) var team_num = round_info.style.team_num return Promise.all([con.teams.read(), utab.teams.results.organize(considering_rounds, {simple: simple, force: force}), con.teams.institutions.read()]).then(function (vs) { var [teams, compiled_team_results, teams_to_institutions] = vs var allocation = algorithm === 'standard' ? alloc.standard.teams.get(teams, compiled_team_results, teams_to_institutions, filters, round_info) : alloc.wudc.teams.get(teams, compiled_team_results, round_info) var new_allocation = checks.allocations.teams.check(allocation, teams, compiled_team_results, teams_to_institutions, team_num)/////// return allocation }) }) }, /** * checks allocation(No side effect) * @memberof! Tournament.allocations.teams * @function Tournament.allocations.teams.check * @param allocation * @return {Promise.&lt;Square[]&gt;} */ check: function(allocation) { loggers.allocations('allocations.teams.check is called') loggers.allocations('debug', 'arguments are: '+JSON.stringify(arguments)) return con.rounds.read().then(function (round_info) { var current_round_num = round_info.current_round_num var considering_rounds = _.range(1, current_round_num) return Promise.all([con.teams.read(), teams.results.organize(considering_rounds), con.teams.institutions.read()]).then(function (vs) { var [teams, compiled_team_results, teams_to_institutions] = vs var new_allocation = checks.allocations.teams.check(allocation, teams, compiled_team_results, teams_to_institutions, team_num)/////// return new_allocation }) }) } } /** * Provides interfaces related to adjudicator allocation * @namespace Tournament.allocations.adjudicators * @memberof Tournament.allocations */ this.allocations.adjudicators = { get: function(allocation, { filters: filters=['by_bubble', 'by_strength', 'by_attendance', 'by_conflict', 'by_institution', 'by_past'], simple: simple = false, force: force = false, algorithm: algorithm = 'standard', assign: assign = 'high_to_high',// or middle_to_high, middle_to_slight, high_to_slight scatter: scatter = false, numbers: numbers = {chairs: 2, panels: 1, trainees: 1} }={}) { loggers.allocations('allocations.adjudicators.get is called') loggers.allocations('debug', 'arguments are: '+JSON.stringify(arguments)) return con.rounds.read().then(function (round_info) { var current_round_num = round_info.current_round_num var considering_rounds = _.range(1, current_round_num) return Promise.all([con.teams.read(), con.adjudicators.read(), utab.teams.results.organize(considering_rounds, {force: force, simple: simple}), utab.adjudicators.results.organize(considering_rounds, {force: force}), con.teams.institutions.read(), con.adjudicators.institutions.read(), con.adjudicators.conflicts.read()]).then(function (vs) { var [teams, adjudicators, compiled_team_results, compiled_adjudicator_results, teams_to_institutions, adjudicators_to_institutions, adjudicators_to_conflicts] = vs if (algorithm === 'standard') { var new_allocation = alloc.standard.adjudicators.get(allocation, adjudicators, teams, compiled_team_results, compiled_adjudicator_results, teams_to_institutions, adjudicators_to_institutions, adjudicators_to_conflicts, filters, numbers) } else if (algorithm === 'traditional') { var new_allocation = alloc.traditional.adjudicators.get(allocation, adjudicators, compiled_team_results, compiled_adjudicator_results, teams_to_institutions, adjudicators_to_institutions, adjudicators_to_conflicts, numbers, assign, scatter) } new_allocation = checks.allocations.adjudicators.check(allocation, adjudicators, compiled_team_results, compiled_adjudicator_results, teams_to_institutions, adjudicators_to_institutions, adjudicators_to_conflicts) return new_allocation }) }) }, check: function(allocation) { loggers.allocations('allocations.adjudicators.check is called') loggers.allocations('debug', 'arguments are: '+JSON.stringify(arguments)) return con.rounds.read().then(function (round_info) { var current_round_num = round_info.current_round_num var considering_rounds = _.range(1, current_round_num) return Promise.all([con.teams.read(), con.adjudicators.read(), con.venues.read(), teams.results.organize(considering_rounds), adjudicators.results.organize(considering_rounds), con.teams.institutions.read(), con.adjudicators.institutions.read(), con.adjudicators.conflicts.read()]).then(function (vs) { var [teams, adjudicators, compiled_team_results, compiled_adjudicator_results, teams_to_institutions, adjudicators_to_institutions, adjudicators_to_conflicts] = vs var new_allocation = checks.allocations.adjudicators.check(allocation, adjudicators, compiled_team_results, compiled_adjudicator_results, teams_to_institutions, adjudicators_to_institutions, adjudicators_to_conflicts) return new_allocation }) }) } } /** * Provides interfaces related to venue allocation * @namespace Tournament.allocations.venues * @memberof Tournament.allocations */ this.allocations.venues = { /** * get venue allocation from allocation * @param {Square[]} allocation allocation * @param {Object} options * @param {Boolean} [options.shuffle=false] if true, it randomly allocates venues to squares so that no one can guess the current rankings of teams. * @return {Promise.&lt;Square[]&gt;} */ get: function(allocation, options={shuffle: false}) { loggers.allocations('allocations.venues.get is called') loggers.allocations('debug', 'arguments are: '+JSON.stringify(arguments)) return con.rounds.read().then(function (round_info) { var current_round_num = round_info.current_round_num var considering_rounds = _.range(1, current_round_num) return Promise.all([con.venues.read(), con.teams.results.organize(considering_rounds)]).then(function (vs) { var [venues, compiled_team_results] = vs var new_allocation = alloc.standard.venues.get(allocation, venues, compiled_team_results, round_info, options) new_allocation = checks.allocations.venues.check(new_allocation, venues) return new_allocation }) }) }, check: function(allocation) { loggers.allocations('allocations.venues.check is called') loggers.allocations('debug', 'arguments are: '+JSON.stringify(arguments)) return con.rounds.read().then(function (round_info) { var current_round_num = round_info.current_round_num var considering_rounds = _.range(1, current_round_num) return Promise.all([con.venues.read(), con.teams.results.organize(considering_rounds)]).then(function (vs) { var [venues, compiled_team_results] = vs var new_allocation = checks.allocations.venues.check(allocation, venues) return new_allocation }) }) } } /** * closes connection to the tournament database. * @memberof! Tournament * @function Tournament.close */ this.close = con.close } } exports.Tournament = Tournament × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" DocStrap Namespaces Tournament.adjudicatorsTournament.adjudicators.resultsTournament.allocationsTournament.allocations.adjudicatorsTournament.allocations.teamsTournament.allocations.venuesTournament.debatersTournament.debaters.resultsTournament.institutionsTournament.roundsTournament.teamsTournament.teams.debatersTournament.teams.resultsTournament.venues Classes Tournament Global Global Global Type Definitions Adjudicator Represents an adjudicator. Properties: Name Type Description id Number id of the Adjudicator preev Number pre evaluation(judge test) of the Adjudicator name String name of the Adjudicator available Boolean available user_defined_data Object user defined data Source: utab.js, line 46 Institution Represents an institution. Properties: Name Type Description id Number id of the Institution name String name of the Institution available Boolean available user_defined_data Object user defined data Source: utab.js, line 66 RawAdjudicatorResult Represents raw adjudicator result. Properties: Name Type Description id Number id of the adjudicator to evaluate from_id Number id of the sender r Number round number at which the result is sent score Number the score of the adjudicator the sender writes watched_teams Array.&lt;Number&gt; teams the adjudicator watched comment String the comment for the adjudicator from the sender user_defined_data Object user defined data Source: utab.js, line 113 RawDebaterResult Represents raw debater result. Properties: Name Type Description id Number id of the debater to evaluate from_id Number id of the sender r Number round number at which the result is sent scores Array.&lt;Number&gt; scores the sender writes user_defined_data Object user defined data Source: utab.js, line 96 Example { id: 1, from_id: 2, r: 1, scores: [75, 0, 36.5] } RawTeamResult Represents raw team result. Properties: Name Type Description id Number id of the team to evaluate from_id Number id of the sender r Number round number at which the result is sent win Number in NA it's either 1(win) or 0(lose), in BP it's the win-points opponents Array.&lt;Number&gt; opponents of the team side String side of the team user_defined_data Object user defined data Source: utab.js, line 75 Example { id: 1, from_id: 2, r: 1, win: 1, opponents: [2], side: &quot;gov&quot; } Square Represents a pair/set of teams in a venue. A minimum unit to be an allocation. Properties: Name Type Description id Number id of the Square teams Array.&lt;Number&gt; teams in the Square chairs Array.&lt;Number&gt; chairs in the Square panels Array.&lt;Number&gt; adjudicators(panels) in the Square trainees Array.&lt;Number&gt; adjudicators(trainees) in the Square warnings Array.&lt;String&gt; warnings venue Number Source: utab.js, line 25 Style Represents debate style. Properties: Name Type Description name String style name debater_num_per_team Number number of debaters per team team_num Number number of team in a Square score_weights Array.&lt;Number&gt; weights of the scores replies Number candidates of replies (Necessary only for testing) reply_num Number number of replies in a Square (Necessary only for testing) Source: utab.js, line 125 Example { name: &quot;ASIAN&quot;, debater_num_per_team: 3, team_num: 2, score_weights: [1, 1, 1, 0.5], replies: [0, 1], reply_num: 1 } Team Represents a team. Properties: Name Type Description id Number id of the Team name String name of the Team available Boolean available user_defined_data Object user defined data Source: utab.js, line 37 TournamentInformation Represents a tournament. Properties: Name Type Description id Number id of the tournament name String name of the tournament current_round_num Number current round total_round_num Number total round style Style style of the tournament user_defined_data Object user defined data Source: utab.js, line 145 Venue Represents a venue. Properties: Name Type Description id Number id of the Venue priority Number priority of the Venue name String name of the Venue available Boolean available user_defined_data Object user defined data Source: utab.js, line 56 × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" DocStrap Namespaces Tournament.adjudicatorsTournament.adjudicators.resultsTournament.allocationsTournament.allocations.adjudicatorsTournament.allocations.teamsTournament.allocations.venuesTournament.debatersTournament.debaters.resultsTournament.institutionsTournament.roundsTournament.teamsTournament.teams.debatersTournament.teams.resultsTournament.venues Classes Tournament Global Global Classes Classes Tournament Namespaces adjudicators results allocations adjudicators teams venues debaters results institutions rounds teams debaters results venues × Search results Close "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" DocStrap Namespaces Tournament.adjudicatorsTournament.adjudicators.resultsTournament.allocationsTournament.allocations.adjudicatorsTournament.allocations.teamsTournament.allocations.venuesTournament.debatersTournament.debaters.resultsTournament.institutionsTournament.roundsTournament.teamsTournament.teams.debatersTournament.teams.resultsTournament.venues Classes Tournament Global Global Namespaces Classes Tournament Namespaces adjudicators results allocations adjudicators teams venues debaters results institutions rounds teams debaters results venues × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" DocStrap Namespaces Tournament.adjudicatorsTournament.adjudicators.resultsTournament.allocationsTournament.allocations.adjudicatorsTournament.allocations.teamsTournament.allocations.venuesTournament.debatersTournament.debaters.resultsTournament.institutionsTournament.roundsTournament.teamsTournament.teams.debatersTournament.teams.resultsTournament.venues Classes Tournament Global Global Index utab.js Interfaces for UTab core. Github Page is here. Version: 2.0 Author: taulukointipalvelut@gmail.com (nswa17) Source: utab.js, line 2 Example var utab = require('./utab.js') var t1 = new utab.Tournament({name: 't1', style: 'NA'})//create a tournament 't1' t1.teams.read().then(console.log)//show all teams t1.close()//close connection to t1 database × Search results Close "},"Tournament.html":{"id":"Tournament.html","title":"Class: Tournament","body":" DocStrap Namespaces Tournament.adjudicatorsTournament.adjudicators.resultsTournament.allocationsTournament.allocations.adjudicatorsTournament.allocations.teamsTournament.allocations.venuesTournament.debatersTournament.debaters.resultsTournament.institutionsTournament.roundsTournament.teamsTournament.teams.debatersTournament.teams.resultsTournament.venues Classes Tournament Global Global Class: Tournament Tournament A class to operate a tournament. new Tournament(dict) Parameters: Name Type Description dict Object Properties Name Type Argument Description id Number tournament id name String &lt;optional&gt; tournament name style Style &lt;optional&gt; debate style Source: utab.js, line 160 Namespaces adjudicators allocations debaters institutions rounds teams venues Methods .close() closes connection to the tournament database. Source: utab.js, line 641 × Search results Close "},"Tournament.adjudicators.html":{"id":"Tournament.adjudicators.html","title":"Namespace: adjudicators","body":" DocStrap Namespaces Tournament.adjudicatorsTournament.adjudicators.resultsTournament.allocationsTournament.allocations.adjudicatorsTournament.allocations.teamsTournament.allocations.venuesTournament.debatersTournament.debaters.resultsTournament.institutionsTournament.roundsTournament.teamsTournament.teams.debatersTournament.teams.resultsTournament.venues Classes Tournament Global Global Namespace: adjudicators Tournament. adjudicators Provides interfaces related to adjudicators Source: utab.js, line 365 Namespaces results × Search results Close "},"Tournament.adjudicators.results.html":{"id":"Tournament.adjudicators.results.html","title":"Namespace: results","body":" DocStrap Namespaces Tournament.adjudicatorsTournament.adjudicators.resultsTournament.allocationsTournament.allocations.adjudicatorsTournament.allocations.teamsTournament.allocations.venuesTournament.debatersTournament.debaters.resultsTournament.institutionsTournament.roundsTournament.teamsTournament.teams.debatersTournament.teams.resultsTournament.venues Classes Tournament Global Global Namespace: results Tournament.adjudicators. results Source: utab.js, line 371 Methods .organize(r_or_rs [, options]) Summarizes adjudicator results(No side effect) Parameters: Name Type Argument Description r_or_rs Number | Array.&lt;Number&gt; round number(s) used to summarize results options &lt;optional&gt; Properties Name Type Argument Default Description force Boolean &lt;optional&gt; false if true, it does not check raw results(not recommended) Source: utab.js, line 384 Returns: summarized adjudicator results Type Promise × Search results Close "},"Tournament.allocations.html":{"id":"Tournament.allocations.html","title":"Namespace: allocations","body":" DocStrap Namespaces Tournament.adjudicatorsTournament.adjudicators.resultsTournament.allocationsTournament.allocations.adjudicatorsTournament.allocations.teamsTournament.allocations.venuesTournament.debatersTournament.debaters.resultsTournament.institutionsTournament.roundsTournament.teamsTournament.teams.debatersTournament.teams.resultsTournament.venues Classes Tournament Global Global Namespace: allocations Tournament. allocations Provides interfaces related to allocations Source: utab.js, line 455 Namespaces adjudicators teams venues × Search results Close "},"Tournament.allocations.adjudicators.html":{"id":"Tournament.allocations.adjudicators.html","title":"Namespace: adjudicators","body":" DocStrap Namespaces Tournament.adjudicatorsTournament.adjudicators.resultsTournament.allocationsTournament.allocations.adjudicatorsTournament.allocations.teamsTournament.allocations.venuesTournament.debatersTournament.debaters.resultsTournament.institutionsTournament.roundsTournament.teamsTournament.teams.debatersTournament.teams.resultsTournament.venues Classes Tournament Global Global Namespace: adjudicators Tournament.allocations. adjudicators Provides interfaces related to adjudicator allocation Source: utab.js, line 541 × Search results Close "},"Tournament.allocations.teams.html":{"id":"Tournament.allocations.teams.html","title":"Namespace: teams","body":" DocStrap Namespaces Tournament.adjudicatorsTournament.adjudicators.resultsTournament.allocationsTournament.allocations.adjudicatorsTournament.allocations.teamsTournament.allocations.venuesTournament.debatersTournament.debaters.resultsTournament.institutionsTournament.roundsTournament.teamsTournament.teams.debatersTournament.teams.resultsTournament.venues Classes Tournament Global Global Namespace: teams Tournament.allocations. teams Provides interfaces related to team allocation Source: utab.js, line 475 Methods .check(allocation) checks allocation(No side effect) Parameters: Name Type Description allocation Source: utab.js, line 517 Returns: Type Promise.&lt;Array.&lt;Square&gt;&gt; .get( [options]) get allocation(No side effect) Parameters: Name Type Argument Description options Object &lt;optional&gt; Properties Name Type Argument Default Description simple Boolean &lt;optional&gt; false if true, it does not use debater results filters Array.&lt;String&gt; &lt;optional&gt; ['by_strength', 'by_side', 'by_past_opponent', 'by_institution'] filters to compute team allocation in standard algorithm force Boolean &lt;optional&gt; false if true, it does not check the database before creating matchups. (false recommended) algorithm String &lt;optional&gt; 'standard' it computes the allocation using specified algorithm Source: utab.js, line 494 Returns: allocation Type Promise.&lt;Array.&lt;Square&gt;&gt; × Search results Close "},"Tournament.allocations.venues.html":{"id":"Tournament.allocations.venues.html","title":"Namespace: venues","body":" DocStrap Namespaces Tournament.adjudicatorsTournament.adjudicators.resultsTournament.allocationsTournament.allocations.adjudicatorsTournament.allocations.teamsTournament.allocations.venuesTournament.debatersTournament.debaters.resultsTournament.institutionsTournament.roundsTournament.teamsTournament.teams.debatersTournament.teams.resultsTournament.venues Classes Tournament Global Global Namespace: venues Tournament.allocations. venues Provides interfaces related to venue allocation Source: utab.js, line 593 × Search results Close "},"Tournament.debaters.html":{"id":"Tournament.debaters.html","title":"Namespace: debaters","body":" DocStrap Namespaces Tournament.adjudicatorsTournament.adjudicators.resultsTournament.allocationsTournament.allocations.adjudicatorsTournament.allocations.teamsTournament.allocations.venuesTournament.debatersTournament.debaters.resultsTournament.institutionsTournament.roundsTournament.teamsTournament.teams.debatersTournament.teams.resultsTournament.venues Classes Tournament Global Global Namespace: debaters Tournament. debaters Interfaces related to debaters Source: utab.js, line 408 Namespaces results × Search results Close "},"Tournament.debaters.results.html":{"id":"Tournament.debaters.results.html","title":"Namespace: results","body":" DocStrap Namespaces Tournament.adjudicatorsTournament.adjudicators.resultsTournament.allocationsTournament.allocations.adjudicatorsTournament.allocations.teamsTournament.allocations.venuesTournament.debatersTournament.debaters.resultsTournament.institutionsTournament.roundsTournament.teamsTournament.teams.debatersTournament.teams.resultsTournament.venues Classes Tournament Global Global Namespace: results Tournament.debaters. results Interfaces related to debater results Source: utab.js, line 414 Methods .organize(r_or_rs [, options]) Summarizes debater results(No side effect) Parameters: Name Type Argument Description r_or_rs Number | Array.&lt;Number&gt; round number(s) used to summarize results options &lt;optional&gt; Properties Name Type Argument Default Description force Boolean &lt;optional&gt; false if true, it does not check raw results(not recommended) Source: utab.js, line 428 Returns: summarized debater results Type Promise × Search results Close "},"Tournament.institutions.html":{"id":"Tournament.institutions.html","title":"Namespace: institutions","body":" DocStrap Namespaces Tournament.adjudicatorsTournament.adjudicators.resultsTournament.allocationsTournament.allocations.adjudicatorsTournament.allocations.teamsTournament.allocations.venuesTournament.debatersTournament.debaters.resultsTournament.institutionsTournament.roundsTournament.teamsTournament.teams.debatersTournament.teams.resultsTournament.venues Classes Tournament Global Global Namespace: institutions Tournament. institutions Interfaces related to institutions Source: utab.js, line 448 × Search results Close "},"Tournament.rounds.html":{"id":"Tournament.rounds.html","title":"Namespace: rounds","body":" DocStrap Namespaces Tournament.adjudicatorsTournament.adjudicators.resultsTournament.allocationsTournament.allocations.adjudicatorsTournament.allocations.teamsTournament.allocations.venuesTournament.debatersTournament.debaters.resultsTournament.institutionsTournament.roundsTournament.teamsTournament.teams.debatersTournament.teams.resultsTournament.venues Classes Tournament Global Global Namespace: rounds Tournament. rounds Interfaces related to tournament operation Source: utab.js, line 396 × Search results Close "},"Tournament.teams.html":{"id":"Tournament.teams.html","title":"Namespace: teams","body":" DocStrap Namespaces Tournament.adjudicatorsTournament.adjudicators.resultsTournament.allocationsTournament.allocations.adjudicatorsTournament.allocations.teamsTournament.allocations.venuesTournament.debatersTournament.debaters.resultsTournament.institutionsTournament.roundsTournament.teamsTournament.teams.debatersTournament.teams.resultsTournament.venues Classes Tournament Global Global Namespace: teams Tournament. teams Provides Interfaces related to teams Source: utab.js, line 171 Namespaces debaters results Methods .create(team [, force]) creates team.//TESTED//Attention: It throws an error if the specified team already exists. Parameters: Name Type Argument Default Description team Properties Name Type Argument Default Description id Number id of the team to create name Number &lt;optional&gt; &quot;&quot; name of the team to create available Number &lt;optional&gt; true id of the team to create force Boolean &lt;optional&gt; false if true, it creates the specified team regardless of wheter the name specified already exists Source: utab.js, line 185 Throws: AlreadyExists Type Promise Returns: Created team Type Promise.&lt;Team&gt; .delete(team) deletes specified team.//TESTED//Attention: It throws an error if the specified team does not exist. Parameters: Name Type Description team Properties Name Type Description id Number id of the team to delete Source: utab.js, line 199 Throws: DoesNotExist Type Promise Returns: Deleted team Type Promise.&lt;Team&gt; .find(team) finds on specified condition(No side effect)//TESTED// Parameters: Name Type Description team Properties Name Type Argument Description id Number &lt;optional&gt; id of the team to find name Number &lt;optional&gt; name of the team to find available Number &lt;optional&gt; id of the team to find Source: utab.js, line 210 Returns: Teams Type Promise.&lt;Array.&lt;Team&gt;&gt; .read() returns all teams(No side effect) Source: utab.js, line 177 Returns: Teams Type Promise.&lt;Array.&lt;Team&gt;&gt; .update(team) checks whether specified team exists Parameters: Name Type Description team Properties Name Type Argument Description id Number &lt;optional&gt; id of the team to update name Number &lt;optional&gt; name of the team to update available Number &lt;optional&gt; id of the team to update Source: utab.js, line 234 Throws: DoesNotExist Returns: Type Promise.&lt;Boolean&gt; .update(team) updates specified team//TESTED//Attention: It throws an error if the specified team does not exist. Parameters: Name Type Description team Properties Name Type Argument Default Description id Number id of the team to update name Number &lt;optional&gt; &quot;&quot; name of the team to update available Number &lt;optional&gt; true id of the team to update Source: utab.js, line 221 Throws: DoesNotExist Returns: Updated team Type Promise.&lt;Team&gt; × Search results Close "},"Tournament.teams.debaters.html":{"id":"Tournament.teams.debaters.html","title":"Namespace: debaters","body":" DocStrap Namespaces Tournament.adjudicatorsTournament.adjudicators.resultsTournament.allocationsTournament.allocations.adjudicatorsTournament.allocations.teamsTournament.allocations.venuesTournament.debatersTournament.debaters.resultsTournament.institutionsTournament.roundsTournament.teamsTournament.teams.debatersTournament.teams.resultsTournament.venues Classes Tournament Global Global Namespace: debaters Tournament.teams. debaters Interfaces related to teams to debaters Source: utab.js, line 298 Methods .create(dict) sets debaters to a team.Attention: It throws an error if the specified team has debaters. Parameters: Name Type Description dict Properties Name Type Description id Number id of the team to set debaters debaters Array.&lt;Number&gt; debaters to set r Number round where the team has the debaters Source: utab.js, line 310 Throws: AlreadyExists Type Promise Returns: Created team Type Promise .delete(options) deletes debaters from specified team.Attention: It throws an error if the specified team does not exist. Parameters: Name Type Description options Properties Name Type Description id Number id of the team to delete r Number round where the team has the debaters Deprecated: Yes Source: utab.js, line 323 Throws: DoesNotExist Type Promise Returns: Team Type Promise .find(options) finds on specified condition(No side effect) Parameters: Name Type Description options Properties Name Type Argument Description id Number &lt;optional&gt; id of the team to delete r Number &lt;optional&gt; round where the team has the debaters debaters Array.&lt;Number&gt; &lt;optional&gt; debaters Source: utab.js, line 336 Returns: Teams Type Promise .read() returns teams to debaters(No side effect) Source: utab.js, line 303 Returns: Teams to debaters Type Promise .update(options) updates debaters of specified teamAttention: It throws an error if the specified team does not exist. Parameters: Name Type Description options Properties Name Type Description id Number id of the team r Number round where the team has the debaters debaters Array.&lt;Number&gt; debaters of the team Source: utab.js, line 347 Throws: DoesNotExist Returns: Team Type Promi × Search results Close "},"Tournament.teams.results.html":{"id":"Tournament.teams.results.html","title":"Namespace: results","body":" DocStrap Namespaces Tournament.adjudicatorsTournament.adjudicators.resultsTournament.allocationsTournament.allocations.adjudicatorsTournament.allocations.teamsTournament.allocations.venuesTournament.debatersTournament.debaters.resultsTournament.institutionsTournament.roundsTournament.teamsTournament.teams.debatersTournament.teams.resultsTournament.venues Classes Tournament Global Global Namespace: results Tournament.teams. results Source: utab.js, line 246 Methods .organize(r_or_rs, options) Summarizes team results(No side effect) Parameters: Name Type Description r_or_rs Number | Array.&lt;Number&gt; round number(s) used to summarize results options [options] for summarization Properties Name Type Argument Default Description simple Boolean &lt;optional&gt; false only use team results. No debater results is considered thus unable to output team points force Boolean &lt;optional&gt; false if true, it does not check raw results(not recommended) Source: utab.js, line 267 Returns: summarized team results Type Promise .read() reads all raw team results(No side effect) Source: utab.js, line 250 Returns: Type Promise.&lt;Array.&lt;RawTeamResult&gt;&gt; × Search results Close "},"Tournament.venues.html":{"id":"Tournament.venues.html","title":"Namespace: venues","body":" DocStrap Namespaces Tournament.adjudicatorsTournament.adjudicators.resultsTournament.allocationsTournament.allocations.adjudicatorsTournament.allocations.teamsTournament.allocations.venuesTournament.debatersTournament.debaters.resultsTournament.institutionsTournament.roundsTournament.teamsTournament.teams.debatersTournament.teams.resultsTournament.venues Classes Tournament Global Global Namespace: venues Tournament. venues Interfaces related to venues Source: utab.js, line 402 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
